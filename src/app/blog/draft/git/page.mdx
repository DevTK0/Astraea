This article discusses the different ways to integrate changes from one branch to another in git.

## Rebasing
Rebasing is when you move an entire branch to the front of your current branch.
```git
git rebase BRANCH-NAME
```

- Rebase 'destroys' the original branch.
- Rebase rewrites history.
- Rebase results in a clean, linear history.

## Merging
Merging is when you integrate changes from another branch to your current branch as a new commit.

```git
git merge BRANCH-NAME
```

- Merging creates a new commit in the main branch containing all the merged changes.
- Merging retains the original commits from the feature branches.
- Merging results in a non-linear history.

## Squashing
Squashing is when you combine multiple commits into a single commit.

- Squashing is useful for cleaning up your commit history.
    - `git commit --fixup <commitId>` and `git rebase --autosquash` will allow you to squash fixup commits.
    - `git rebase -i` will allow you to squash commits interactively.
- Squashing is especially useful for making `git revert` easier.
- Squashing can be used to make handling merge conflicts easier as you'll only need to handle them once.

## Cherry Picking
Cherry picking is when you take a single commit from one branch and apply it to another branch.

```git
git cherry-pick COMMIT-ID
```

- Cherry picking can become problematic when you pick out commits that haven't been tested on their own.

## Bisect
Git bisect is a tool that allows you to find the commit that introduced a bug.

```git
```

## Revert
Git revert is a tool that allows you to undo a commit.

```git
```

## My philosophy on git
Personally, I don't really care that much about the asthetics of the commit history. I'm mainly interested in the utility of the approaches.

1. Ability to easily revert changes.

The easiest way to revert a change would be a single, squashed commit to main. Can be done in both rebase and merge, but merge retains the original commit history.

2. Ability to debug using git bisect.

Using bisect with merges can be tricky as the merge commits can "break up" the good path, preventing you from finding the exact commit on the feature branch that caused the issue.

Rebase is not entirely without its issues. Unless you squash your commits, there is no guarantee that a rebased commit will be in a working state. 

3. Commits as documentation

Rebase rewrites history, leading to a potentially inaccurate representation of the actual changes. It is also destructive on the feature branch.

4. Productivity

Using tools like Graphite can greatly simplify the merge and PR process for both merging and rebasing.

## Conclusion
In the end, I think both approaches leave a lot to be desired. Currently, I feel that having a detailed history is unnecessary and that having too fine grained commits can make it harder to revert changes and to use git bisect. As such, I'll be adopting the squash, rebase and merge approach and see how it goes.