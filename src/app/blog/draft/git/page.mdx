This article discusses the different ways to integrate changes from one branch to another in git.

## Rebasing
Rebasing is when you move an entire branch to the front of your current branch.
```git
git rebase BRANCH-NAME
```

## Merging
Merging is when you integrate changes from another branch to your current branch as a new commit.

```git
git merge BRANCH-NAME
```

## Squashing
Squashing is when you combine multiple commits into a single commit.

- Squashing is useful for cleaning up your commit history.
    - `git commit --fixup <commitId>` and `git rebase --autosquash` will allow you to squash fixup commits.
    - `git rebase -i` will allow you to squash commits interactively.
- Squashing is especially useful for making `git revert` easier.
- Squashing can be used to make handling merge conflicts easier as you'll only need to handle them once.


## My philosophy on git
Personally, I don't really care that much about the asthetics of the commit history. I'm mainly interested in the utility of the approaches.

1. Ability to easily revert changes.

The easiest way to revert a change would be a single, squashed commit to main. Can be done in both rebase and merge, but merge retains the original commit history.

2. Ability to debug using git bisect.

Using bisect with merges can be tricky as the merge commits can "break up" the good path, preventing you from finding the exact commit on the feature branch that caused the issue.

Rebase is not entirely without its issues. Unless you squash your commits, there is no guarantee that a rebased commit will be in a working state. 

3. Tracking history

Rebase rewrites history, leading to a potentially inaccurate representation of the actual changes. It is also destructive on the feature branch.

4. Productivity

Using tools like Graphite can greatly simplify the merge and PR process for both merging and rebasing.

## Conclusion
In the end, I think both approaches leave a lot to be desired. Currently, I feel that having a detailed history is unnecessary and that having too fine grained commits can make it harder to revert changes and use git bisect. As such, I'll be adopting the squash, rebase and merge approach and see how it goes.